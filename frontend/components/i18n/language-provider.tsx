"use client";

import { createContext, useContext, useEffect, useMemo, useState } from "react";

type Language = "fr" | "en";

const STORAGE_KEY = "prooforigin-language";

const translations = {
  fr: {
    nav: {
      pricing: "Tarifs",
      dashboard: "Dashboard",
      docs: "Documentation API",
    },
    language: {
      switchToEnglish: "Passer en anglais",
      switchToFrench: "Passer en fran√ßais",
      indicatorFrench: "üá´üá∑ FR",
      indicatorEnglish: "üá¨üáß EN",
    },
    theme: {
      light: "‚òÄÔ∏è Mode jour",
      dark: "üåô Mode nuit",
    },
    home: {
      heroBadge: "Proof-as-a-Service",
      heroTitle: "Le passeport infalsifiable de vos cr√©ations.",
      heroSubtitle:
        "ProofOrigin combine hashing SHA-256, signatures Ed25519, ancrage blockchain et horodatage OpenTimestamps pour d√©livrer des certificats PDF v√©rifiables √† l‚Äô√©chelle mondiale. Upload unique, API batch ou int√©gration IA : tout est pr√™t.",
      ctaUpload: "D√©poser une cr√©ation",
      ctaPricing: "D√©couvrir les plans",
      ctaDocs: "Documentation API",
      featureAnchorTitle: "Ancrage blockchain",
      featureAnchorDescription: "Polygon, Base, Arbitrum & OpenTimestamps, orchestr√©s automatiquement.",
      featureSdkTitle: "Webhooks & SDK",
      featureSdkDescription: "Recevez les preuves en push et int√©grez nos SDK Python & Node en quelques lignes.",
      integrationHeading: "Connectez ProofOrigin √† votre stack",
      integrationBadge: "API REST / OAuth2 / Webhooks",
      oauthTitle: "OAuth2 + JWT",
      oauthDescription:
        "Connexion rapide via Google, GitHub ou Auth0. Les tokens JWT s√©curisent vos requ√™tes serveur √† serveur.",
      oauthBullets: [
        "Rotation de cl√©s Ed25519 chiffr√©es c√¥t√© serveur",
        "Gestion de comptes multi-√©quipes et r√¥les",
        "API keys illimit√©es avec quotas par plan",
      ],
      aiTitle: "Proof for AI",
      aiDescription:
        "Endpoint /api/v1/ai/proof pour certifier vos g√©n√©rations IA (model_name, prompt, timestamp).",
      aiBullets: [
        "Webhook de retour pour Runway, Midjourney, StableDiffusion",
        "Badges dynamiques ¬´ ProofOrigin Certified ¬ª",
        "Batch processing jusqu‚Äô√† 10 000 contenus",
      ],
      ctaBannerTitle: "Pr√™t √† passer en production ?",
      ctaBannerDescription:
        "D√©ployez sur Render gr√¢ce au blueprint fourni et suivez vos preuves depuis le dashboard Next.js.",
      ctaBannerButton: "Ouvrir le dashboard",
    },
    upload: {
      heading: "Uploader et certifier en direct",
      subheading: "Hash SHA-256, signature Ed25519 et certificat PDF instantan√©.",
      apiKeyLabel: "Cl√© API (X-API-Key)",
      keyPasswordLabel: "Mot de passe de cl√©",
      textLabel: "Texte √† certifier",
      textPlaceholder: "Collez ici une description, un prompt IA, un script‚Ä¶",
      fileLabel: "Fichier (optionnel)",
      submit: "Certifier maintenant",
      submitting: "G√©n√©ration‚Ä¶",
      compatibilityBadge: "Compatible Polygon ¬∑ Base ¬∑ OpenTimestamps",
      statusMissingApiKey: "Merci de renseigner votre cl√© API X-API-Key.",
      statusMissingKeyPassword: "Votre mot de passe de cl√© priv√©e est requis.",
      statusMissingPayload: "Ajoutez un fichier ou un texte √† certifier.",
      statusLoading: "G√©n√©ration de la preuve en cours‚Ä¶",
      statusSuccess: "Preuve g√©n√©r√©e avec succ√®s. Vous pouvez t√©l√©charger le certificat.",
      statusError: "Impossible de g√©n√©rer la preuve : {{message}}",
      proofHeading: "Preuve #",
      hashLabel: "Hash :",
      createdAtLabel: "Cr√©√©e le :",
      anchorLink: "Voir l‚Äôancrage blockchain",
      anchorPending: "En attente d‚Äôancrage blockchain‚Ä¶",
      verifyButton: "V√©rifier publiquement",
      downloadButton: "T√©l√©charger le certificat PDF",
    },
    verify: {
      heading: "V√©rification publique instantan√©e",
      subheading: "Consultez le statut, la date et t√©l√©chargez le certificat.",
      hashLabel: "Hash (SHA-256)",
      hashPlaceholder: "0x‚Ä¶",
      submit: "V√©rifier",
      submitting: "Recherche‚Ä¶",
      statusPrompt: "Indiquez un hash √† contr√¥ler",
      statusLoading: "Contr√¥le en cours‚Ä¶",
      statusVerified: "Preuve trouv√©e",
      statusMissing: "Hash inconnu",
      statusError: "Erreur : {{message}}",
      resultStatusLabel: "Statut :",
      resultVerified: "‚úÖ Valid√©",
      resultMissing: "‚ùå Inconnu",
      resultCreatedAt: "Cr√©√© le :",
      resultOwner: "Propri√©taire :",
      anchorLink: "Voir la transaction blockchain",
      downloadButton: "T√©l√©charger le certificat PDF",
    },
    dashboard: {
      heading: "Dashboard ProofOrigin",
      subheading:
        "Consultez vos preuves, quotas API et g√©n√©rez des sessions de paiement Stripe pour upgrader instantan√©ment.",
      usageTitle: "Suivi d‚Äôusage API",
      usageSubtitle: "Rafra√Æchissez vos quotas et lancez un upgrade de plan.",
      syncLabel: "Cl√© API",
      syncButton: "Synchroniser",
      checkoutTokenLabel: "Jeton d‚Äôacc√®s (Bearer)",
      checkoutPlanLabel: "Plan cible",
      checkoutButton: "G√©n√©rer une session Stripe",
      checkoutOpen: "Ouvrir la session de paiement",
      checkoutNeedToken: "Fournissez un jeton d‚Äôacc√®s JWT",
      checkoutLoading: "G√©n√©ration de la session Stripe en cours‚Ä¶",
      checkoutReady: "Session pr√™te pour le plan {{plan}}",
      checkoutError: "Impossible de cr√©er la session : {{message}}",
      usageError: "Erreur lors du chargement : {{message}}",
      planLabel: "Plan :",
      proofsLabel: "Preuves g√©n√©r√©es :",
      verificationsLabel: "V√©rifications effectu√©es :",
      creditsLabel: "Cr√©dits restants :",
      rateLabel: "Limite / minute :",
      quotaLabel: "Quota mensuel :",
      lastPaymentLabel: "Dernier paiement :",
      nextBatchLabel: "Prochain lot blockchain :",
      planOptions: {
        free: "Free",
        pro: "Pro",
        business: "Business",
      },
    },
    pricing: {
      heading: "Plans & Tarification",
      subheading:
        "Choisissez le plan adapt√© √† votre flux et g√©n√©rez la session Stripe directement depuis le dashboard.",
      priceSuffix: "/ mois",
      plans: [
        {
          name: "Free",
          price: "0 ‚Ç¨",
          description: "100 preuves par mois, id√©al pour d√©marrer.",
          features: [
            "100 preuves/mois",
            "Limite 30 requ√™tes/min",
            "Certificats PDF et badges",
          ],
          value: "free",
        },
        {
          name: "Pro",
          price: "79 ‚Ç¨",
          description: "Pour les studios cr√©atifs et √©quipes marketing.",
          features: [
            "10 000 preuves/mois",
            "Support webhook prioritaire",
            "API batch et AI Proof inclus",
          ],
          value: "pro",
          highlight: true,
        },
        {
          name: "Business",
          price: "199 ‚Ç¨",
          description: "Pour les plateformes IA et entreprises globales.",
          features: [
            "100 000 preuves/mois",
            "SLA 99.9% et support d√©di√©",
            "Badge dynamique personnalisable",
          ],
          value: "business",
        },
      ],
      choosePlan: "Choisir ce plan",
      contactTitle: "Besoin d‚Äôun onboarding assist√© ?",
      contactDescription:
        "Contactez notre √©quipe pour connecter votre bucket S3, configurer Stripe et automatiser vos webhooks.",
      contactButton: "Contacter un expert",
    },
    publicVerify: {
      notFoundTitle: "Preuve introuvable",
      notFoundDescription: "Impossible de charger le statut pour le hash {{hash}}.",
      backHome: "Revenir √† l‚Äôaccueil",
      loading: "Chargement du statut‚Ä¶",
      heading: "Statut de la preuve",
      hashLabel: "Hash :",
      statusLabel: "Statut :",
      statusVerified: "‚úÖ V√©rifi√©e",
      statusMissing: "‚ùå Non enregistr√©e",
      createdAt: "Date de cr√©ation :",
      owner: "Propri√©taire :",
      anchorLink: "Voir l‚Äôancrage blockchain",
      anchorHeading: "Ancrages & registres",
      anchorPending: "Ancrage en cours, revenez dans un instant pour voir la transaction.",
      downloadButton: "T√©l√©charger le certificat PDF",
      newProof: "G√©n√©rer une nouvelle preuve",
      summary: "Synth√®se",
      riskLabel: "Indice de risque",
      zeroTrustHeading: "V√©rification hors-ligne",
      zeroTrustDescription:
        "Recalculez le hash localement, comparez-le au ledger et au manifest C2PA sans connexion.",
      zeroTrustUpload: "D√©poser un fichier pour v√©rifier",
      zeroTrustVerifying: "Analyse cryptographique en cours‚Ä¶",
      zeroTrustComputed: "Hash recalcul√© :",
      zeroTrustLedger: "Ledger : ",
      zeroTrustManifest: "Manifest C2PA : ",
      zeroTrustOk: "‚úÖ Conforme",
      zeroTrustKo: "‚ö†Ô∏è Divergent",
      zeroTrustNA: "N/A",
      zeroTrustUnavailable: "Module de v√©rification hors-ligne indisponible.",
      receiptsHeading: "Re√ßus & ancres",
    },
    footer: {
      pricing: "Tarifs",
      dashboard: "Dashboard",
      docs: "Documentation API",
      tagline: "¬© {{year}} ProofOrigin. Toutes preuves, un seul hub.",
    },
  },
  en: {
    nav: {
      pricing: "Pricing",
      dashboard: "Dashboard",
      docs: "API Docs",
    },
    language: {
      switchToEnglish: "Switch to English",
      switchToFrench: "Basculer en fran√ßais",
      indicatorFrench: "üá´üá∑ FR",
      indicatorEnglish: "üá¨üáß EN",
    },
    theme: {
      light: "‚òÄÔ∏è Light mode",
      dark: "üåô Dark mode",
    },
    home: {
      heroBadge: "Proof-as-a-Service",
      heroTitle: "The tamper-proof passport for your creations.",
      heroSubtitle:
        "ProofOrigin combines SHA-256 hashing, Ed25519 signatures, blockchain anchoring, and OpenTimestamps to deliver PDF certificates that can be verified worldwide. One-click upload, batch API, or AI integration: everything is ready.",
      ctaUpload: "Submit a creation",
      ctaPricing: "Explore plans",
      ctaDocs: "API Documentation",
      featureAnchorTitle: "Blockchain anchoring",
      featureAnchorDescription: "Polygon, Base, Arbitrum & OpenTimestamps orchestrated automatically.",
      featureSdkTitle: "Webhooks & SDK",
      featureSdkDescription: "Receive proofs via push and integrate our Python & Node SDKs in a few lines.",
      integrationHeading: "Connect ProofOrigin to your stack",
      integrationBadge: "REST API / OAuth2 / Webhooks",
      oauthTitle: "OAuth2 + JWT",
      oauthDescription:
        "Fast onboarding with Google, GitHub, or Auth0. JWT tokens secure your server-to-server requests.",
      oauthBullets: [
        "Server-side encrypted Ed25519 key rotation",
        "Multi-team account management and roles",
        "Unlimited API keys with plan-based quotas",
      ],
      aiTitle: "Proof for AI",
      aiDescription:
        "Endpoint /api/v1/ai/proof to certify your AI generations (model_name, prompt, timestamp).",
      aiBullets: [
        "Webhook callbacks for Runway, Midjourney, StableDiffusion",
        "Dynamic ‚ÄúProofOrigin Certified‚Äù badges",
        "Batch processing up to 10,000 assets",
      ],
      ctaBannerTitle: "Ready to ship to production?",
      ctaBannerDescription:
        "Deploy on Render with the provided blueprint and track your proofs from the Next.js dashboard.",
      ctaBannerButton: "Open the dashboard",
    },
    upload: {
      heading: "Upload and certify instantly",
      subheading: "SHA-256 hash, Ed25519 signature, and PDF certificate in seconds.",
      apiKeyLabel: "API Key (X-API-Key)",
      keyPasswordLabel: "Key password",
      textLabel: "Text to certify",
      textPlaceholder: "Paste a description, AI prompt, script‚Ä¶",
      fileLabel: "File (optional)",
      submit: "Certify now",
      submitting: "Generating‚Ä¶",
      compatibilityBadge: "Polygon ¬∑ Base ¬∑ OpenTimestamps ready",
      statusMissingApiKey: "Please provide your X-API-Key.",
      statusMissingKeyPassword: "Your private key password is required.",
      statusMissingPayload: "Add a file or some text to certify.",
      statusLoading: "Creating your proof‚Ä¶",
      statusSuccess: "Proof generated successfully. You can download the certificate.",
      statusError: "Unable to generate the proof: {{message}}",
      proofHeading: "Proof #",
      hashLabel: "Hash:",
      createdAtLabel: "Created at:",
      anchorLink: "View blockchain anchoring",
      anchorPending: "Waiting for blockchain anchoring‚Ä¶",
      verifyButton: "Verify publicly",
      downloadButton: "Download PDF certificate",
    },
    verify: {
      heading: "Instant public verification",
      subheading: "Check the status, date, and download the certificate.",
      hashLabel: "Hash (SHA-256)",
      hashPlaceholder: "0x‚Ä¶",
      submit: "Verify",
      submitting: "Searching‚Ä¶",
      statusPrompt: "Provide a hash to inspect",
      statusLoading: "Checking‚Ä¶",
      statusVerified: "Proof found",
      statusMissing: "Unknown hash",
      statusError: "Error: {{message}}",
      resultStatusLabel: "Status:",
      resultVerified: "‚úÖ Valid",
      resultMissing: "‚ùå Missing",
      resultCreatedAt: "Created at:",
      resultOwner: "Owner:",
      anchorLink: "View blockchain transaction",
      downloadButton: "Download PDF certificate",
    },
    dashboard: {
      heading: "ProofOrigin Dashboard",
      subheading:
        "Review your proofs, API quotas, and spin up Stripe payment sessions to upgrade instantly.",
      usageTitle: "API usage tracking",
      usageSubtitle: "Refresh your quotas and trigger a plan upgrade.",
      syncLabel: "API key",
      syncButton: "Sync",
      checkoutTokenLabel: "Access token (Bearer)",
      checkoutPlanLabel: "Target plan",
      checkoutButton: "Create Stripe session",
      checkoutOpen: "Open payment session",
      checkoutNeedToken: "Provide a JWT access token",
      checkoutLoading: "Generating Stripe session‚Ä¶",
      checkoutReady: "Session ready for plan {{plan}}",
      checkoutError: "Unable to create the session: {{message}}",
      usageError: "Failed to load usage: {{message}}",
      planLabel: "Plan:",
      proofsLabel: "Proofs generated:",
      verificationsLabel: "Verifications performed:",
      creditsLabel: "Credits remaining:",
      rateLabel: "Rate limit / minute:",
      quotaLabel: "Monthly quota:",
      lastPaymentLabel: "Last payment:",
      nextBatchLabel: "Next blockchain batch:",
      planOptions: {
        free: "Free",
        pro: "Pro",
        business: "Business",
      },
    },
    pricing: {
      heading: "Plans & Pricing",
      subheading: "Pick the plan that fits your flow and launch a Stripe session right from the dashboard.",
      priceSuffix: "/ month",
      plans: [
        {
          name: "Free",
          price: "‚Ç¨0",
          description: "100 proofs per month ‚Äî perfect to get started.",
          features: [
            "100 proofs / month",
            "30 requests / minute limit",
            "PDF certificates and badges",
          ],
          value: "free",
        },
        {
          name: "Pro",
          price: "‚Ç¨79",
          description: "For creative studios and marketing teams.",
          features: [
            "10,000 proofs / month",
            "Priority webhook support",
            "Batch API and AI Proof included",
          ],
          value: "pro",
          highlight: true,
        },
        {
          name: "Business",
          price: "‚Ç¨199",
          description: "For AI platforms and global enterprises.",
          features: [
            "100,000 proofs / month",
            "99.9% SLA with dedicated support",
            "Customizable dynamic badge",
          ],
          value: "business",
        },
      ],
      choosePlan: "Select this plan",
      contactTitle: "Need a guided onboarding?",
      contactDescription:
        "Reach our team to connect your S3 bucket, configure Stripe, and automate your webhooks.",
      contactButton: "Talk to an expert",
    },
    publicVerify: {
      notFoundTitle: "Proof not found",
      notFoundDescription: "Unable to load the status for hash {{hash}}.",
      backHome: "Back to homepage",
      loading: "Loading proof status‚Ä¶",
      heading: "Proof status",
      hashLabel: "Hash:",
      statusLabel: "Status:",
      statusVerified: "‚úÖ Verified",
      statusMissing: "‚ùå Not recorded",
      createdAt: "Created at:",
      owner: "Owner:",
      anchorLink: "View blockchain anchoring",
      anchorHeading: "Anchors & transparency log",
      anchorPending: "Anchoring still pending. Check back shortly for the transaction hash.",
      downloadButton: "Download PDF certificate",
      newProof: "Generate a new proof",
      summary: "Executive summary",
      riskLabel: "Risk index",
      zeroTrustHeading: "Offline verification",
      zeroTrustDescription:
        "Re-hash the asset locally and reconcile it with the ledger & C2PA manifest directly in your browser.",
      zeroTrustUpload: "Drop a file to verify",
      zeroTrustVerifying: "Crunching cryptography‚Ä¶",
      zeroTrustComputed: "Computed hash:",
      zeroTrustLedger: "Ledger check: ",
      zeroTrustManifest: "C2PA manifest: ",
      zeroTrustOk: "‚úÖ Match",
      zeroTrustKo: "‚ö†Ô∏è Mismatch",
      zeroTrustNA: "N/A",
      zeroTrustUnavailable: "Offline verifier unavailable.",
      receiptsHeading: "Receipts & anchors",
    },
    footer: {
      pricing: "Pricing",
      dashboard: "Dashboard",
      docs: "API Docs",
      tagline: "¬© {{year}} ProofOrigin. Every proof, one hub.",
    },
  },
} as const;

type TranslationShape = typeof translations["fr"];

interface LanguageContextValue {
  language: Language;
  setLanguage: (language: Language) => void;
  dictionary: TranslationShape;
}

const LanguageContext = createContext<LanguageContextValue | undefined>(undefined);

export function LanguageProvider({ children }: { children: React.ReactNode }) {
  const [language, setLanguage] = useState<Language>(() => {
    if (typeof window === "undefined") {
      return "fr";
    }
    const stored = window.localStorage.getItem(STORAGE_KEY) as Language | null;
    if (stored === "fr" || stored === "en") {
      return stored;
    }
    return window.navigator.language?.toLowerCase().startsWith("fr") ? "fr" : "en";
  });

  useEffect(() => {
    if (typeof window !== "undefined") {
      window.localStorage.setItem(STORAGE_KEY, language);
    }
  }, [language]);

  useEffect(() => {
    if (typeof document !== "undefined") {
      document.documentElement.lang = language;
    }
  }, [language]);

  const value = useMemo(
    () => ({
      language,
      setLanguage,
      dictionary: translations[language],
    }),
    [language]
  );

  return <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>;
}

export function useLanguage() {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error("useLanguage must be used within a LanguageProvider");
  }
  return { language: context.language, setLanguage: context.setLanguage };
}

export function useTranslations(): TranslationShape {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error("useTranslations must be used within a LanguageProvider");
  }
  return context.dictionary;
}

